use std::fs;
use std::path::Path;

use serde::Serialize;
use ts_rs::TS;

#[derive(TS, Serialize)]
#[ts(type = "number")]
pub struct DynamicAction(pub u8);

#[derive(TS, Serialize)]
pub struct ProceduralOperator {
    #[serde(rename = "type")]
    pub op_type: String,
    pub args: String,
}

#[derive(TS, Serialize)]
pub struct ProceduralRule {
    pub base: String,
    pub ops: Vec<ProceduralOperator>,
}

#[derive(TS, Serialize)]
pub struct ScriptletCall {
    pub name: String,
    #[ts(type = "unknown[]")]
    pub args: Vec<serde_json::Value>,
}

#[derive(TS, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CosmeticPayload {
    pub css: String,
    pub enable_generic: bool,
    pub procedural: Vec<ProceduralRule>,
    pub scriptlets: Vec<ScriptletCall>,
}

#[derive(TS, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UserSettings {
    pub enabled: bool,
    pub cosmetics_enabled: bool,
    pub scriptlets_enabled: bool,
    pub dynamic_filtering_enabled: bool,
    pub removeparam_enabled: bool,
    pub csp_enabled: bool,
    pub response_header_enabled: bool,
    pub disabled_sites: Vec<String>,
}

#[derive(TS, Serialize)]
pub struct DynamicRule {
    pub site: String,
    pub target: String,
    #[serde(rename = "type")]
    pub rule_type: String,
    pub action: DynamicAction,
}

fn export_decl(decl: &str) -> String {
    if let Some(rest) = decl.strip_prefix("export ") {
        return format!("export {}", rest);
    }
    if let Some(rest) = decl.strip_prefix("type ") {
        return format!("export type {}", rest);
    }
    if let Some(rest) = decl.strip_prefix("interface ") {
        return format!("export interface {}", rest);
    }
    format!("export {}", decl)
}

pub fn export_ts_types(output_path: &Path) -> Result<(), String> {
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create '{}': {}", parent.display(), e))?;
    }

    let mut out = String::new();
    out.push_str("// Generated by bb-cli gen-types. Do not edit.\n\n");
    out.push_str(&export_decl(&DynamicAction::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&ProceduralOperator::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&ProceduralRule::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&ScriptletCall::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&CosmeticPayload::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&DynamicRule::decl()));
    out.push_str("\n\n");
    out.push_str(&export_decl(&UserSettings::decl()));
    out.push('\n');

    fs::write(output_path, out)
        .map_err(|e| format!("Failed to write '{}': {}", output_path.display(), e))?;
    Ok(())
}
